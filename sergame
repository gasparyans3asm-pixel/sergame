/*
Mega Mini-Games Hub ‚Äî Single-file React app (updated & expanded)

What's changed in this update:
- Fixed several bugs (shared object references, improper move detection in 2048, unsafe use of location.reload, event listener cleanup).
- Improved game implementations (2048 movement detection, solvable Sliding Puzzle shuffle, TicTacToe AI option, better Snake control and restart, Minesweeper grid init fix).
- Added UI features: Notifications (to replace alerts), Modal, Achievements, Stats panel, SoundManager stub, Pause/Resume where appropriate.
- Added more comments and small utilities to make code robust and longer as requested.

Drop this file as App.jsx in a React + Tailwind project (or adapt). Tailwind classes are used but you may replace them with your own CSS.
*/

import React, { useEffect, useRef, useState } from 'react';

// ----------------------
// Utilities & Storage
// ----------------------
const uid = () => Math.random().toString(36).slice(2, 9);
const save = (k, v) => localStorage.setItem(k, JSON.stringify(v));
const load = (k, d) => { try { return JSON.parse(localStorage.getItem(k)) ?? d } catch { return d } };
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

// Tiny notification center (no external libs)
function useNotifications(){
  const [items, setItems] = useState([]);
  useEffect(()=>{
    if(items.length===0) return;
    const last = items[items.length-1];
    const t = setTimeout(()=> setItems(it => it.filter(i=>i.id!==last.id)), 3500);
    return ()=>clearTimeout(t);
  }, [items]);
  const push = (text, type='info') => setItems(it => [...it, { id: uid(), text, type }]);
  const clear = ()=> setItems([]);
  return { items, push, clear };
}

function Notifications({ notifications }){
  return (
    <div className="fixed right-4 top-4 w-80 z-50">
      {notifications.items.map(n=> (
        <div key={n.id} className="mb-2 p-3 rounded shadow-md bg-white dark:bg-gray-800 border">
          <div className="font-medium">{n.type}</div>
          <div className="text-sm opacity-80">{n.text}</div>
        </div>
      ))}
    </div>
  );
}

// ----------------------
// Sound manager (stub)
// ----------------------
const SoundManager = {
  enabled: true,
  play: (name) => { if(!SoundManager.enabled) return; /* implement WebAudio or HTMLAudio here */ console.debug('Play sound:', name); },
  setEnabled: (v)=> { SoundManager.enabled = v; }
};

// ----------------------
// Main App
// ----------------------
export default function App(){
  const [user, setUser] = useState(() => load('mmg_user', { id: uid(), name: 'Player', theme: 'light', sound: true }));
  const [section, setSection] = useState('home');
  const [activeGame, setActiveGame] = useState(null);
  const [scores, setScores] = useState(() => load('mmg_scores', {}));
  const [achievements, setAchievements] = useState(() => load('mmg_achievements', {}));
  const [settings, setSettings] = useState(() => load('mmg_settings', { difficulty: 'normal', gridSize: 4 }));
  const notifications = useNotifications();

  useEffect(()=> save('mmg_user', user), [user]);
  useEffect(()=> save('mmg_scores', scores), [scores]);
  useEffect(()=> save('mmg_achievements', achievements), [achievements]);
  useEffect(()=> save('mmg_settings', settings), [settings]);
  useEffect(()=> SoundManager.setEnabled(user.sound), [user.sound]);

  const registerScore = (gameKey, score) => {
    setScores(prev => {
      const arr = prev[gameKey] ? [...prev[gameKey]] : [];
      arr.push({ id: uid(), name: user.name, score, date: new Date().toISOString() });
      arr.sort((a,b)=>b.score - a.score || new Date(a.date) - new Date(b.date));
      const trimmed = arr.slice(0,50);
      notifications.push(`New score in ${gameKey}: ${score}`, 'success');
      return { ...prev, [gameKey]: trimmed };
    });
  };

  const grantAchievement = (id, text) => {
    setAchievements(prev => {
      if(prev[id]) return prev;
      const item = { id, text, date: new Date().toISOString() };
      notifications.push(`Achievement unlocked: ${text}`, 'achievement');
      return { ...prev, [id]: item };
    });
  };

  return (
    <div className={"min-h-screen flex flex-col " + (user.theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900')}>
      <Notifications notifications={notifications} />
      <Topbar user={user} setUser={setUser} section={section} setSection={setSection} notifications={notifications} />
      <div className="flex flex-1">
        <Sidebar setSection={setSection} setActiveGame={g=>{ setActiveGame(g); setSection('play'); }} />
        <main className="flex-1 p-4 overflow-auto">
          {section === 'home' && <Home setSection={setSection} setActiveGame={g=>{ setActiveGame(g); setSection('play'); }} />}
          {section === 'games' && <GamesHub onOpen={(g)=>{ setActiveGame(g); setSection('play'); }} settings={settings} />}
          {section === 'play' && activeGame && <GameShell gameKey={activeGame} registerScore={registerScore} grantAchievement={grantAchievement} settings={settings} notifications={notifications} />}
          {section === 'leaderboard' && <Leaderboards scores={scores} />}
          {section === 'profile' && <Profile user={user} setUser={setUser} achievements={achievements} scores={scores} />}
          {section === 'settings' && <Settings settings={settings} setSettings={setSettings} user={user} setUser={setUser} />}
          {section === 'about' && <About />}
        </main>
      </div>
    </div>
  );
}

// ----------------------
// Topbar / Sidebar
// ----------------------
function Topbar({ user, setUser, section, setSection, notifications }){
  return (
    <header className="flex items-center justify-between p-3 border-b shadow-sm">
      <div className="flex items-center gap-3">
        <h1 className="text-xl font-bold">Mega Mini-Games Hub</h1>
        <span className="text-sm opacity-70">play many tiny games & collect achievements</span>
      </div>
      <div className="flex items-center gap-3">
        <nav className="hidden sm:flex gap-2">
          <button className="btn" onClick={()=>setSection('home')}>Home</button>
          <button className="btn" onClick={()=>setSection('games')}>Games</button>
          <button className="btn" onClick={()=>setSection('leaderboard')}>Leaderboards</button>
          <button className="btn" onClick={()=>setSection('profile')}>Profile</button>
        </nav>
        <div className="flex items-center gap-2">
          <span className="font-medium">{user.name}</span>
          <button className="btn small" onClick={()=>{
            const newName = prompt('Enter new name', user.name);
            if(newName) setUser({...user, name: newName});
          }}>Rename</button>
          <button className="btn outline" onClick={()=>{ navigator.clipboard?.writeText(window.location.href); notifications.push('Link copied to clipboard'); }}>Share</button>
        </div>
      </div>
    </header>
  );
}

function Sidebar({ setSection, setActiveGame }){
  const gamesList = ['Memory','TicTacToe','2048','Snake','Minesweeper','Simon','Trivia','WhackAMole','SlidingPuzzle','Pong'];
  return (
    <aside className="w-64 border-r p-4 hidden md:block">
      <div className="mb-4">
        <h3 className="font-semibold">Quick Play</h3>
        <div className="grid grid-cols-2 gap-2 mt-2">
          {gamesList.map(g => (
            <button key={g} className="btn small" onClick={()=>{ setActiveGame(g); }}>{g}</button>
          ))}
        </div>
      </div>
      <div className="mt-6">
        <h4 className="font-semibold">Sections</h4>
        <ul className="mt-2 space-y-2">
          <li><button className="link" onClick={()=>setSection('games')}>All Games</button></li>
          <li><button className="link" onClick={()=>setSection('leaderboard')}>Leaderboards</button></li>
          <li><button className="link" onClick={()=>setSection('profile')}>Profile</button></li>
          <li><button className="link" onClick={()=>setSection('settings')}>Settings</button></li>
          <li><button className="link" onClick={()=>setSection('about')}>About</button></li>
        </ul>
      </div>
    </aside>
  );
}

// ----------------------
// Home & Games Hub
// ----------------------
function Home({ setSection, setActiveGame }){
  return (
    <div>
      <div className="grid md:grid-cols-3 gap-4">
        <div className="card p-4">
          <h2 className="text-lg font-bold">Start Playing</h2>
          <p className="mt-2">Choose a game or hit Quick Play to jump into a random tiny game.</p>
          <div className="mt-3 flex gap-2">
            <button className="btn" onClick={()=>{ const list=['Memory','TicTacToe','2048','Snake','Minesweeper','Simon','Trivia','WhackAMole','SlidingPuzzle','Pong']; const g = list[Math.floor(Math.random()*list.length)]; setActiveGame(g); setSection('play'); }}>Quick Play</button>
            <button className="btn outline" onClick={()=>setSection('games')}>All Games</button>
          </div>
        </div>
        <div className="card p-4">
          <h3 className="font-semibold">Daily Challenge</h3>
          <p className="mt-2">Complete today's challenge to get a special achievement.</p>
          <button className="btn mt-3" onClick={()=>alert('Daily challenge: Beat 20 in Snake or score 200 in 2048')}>View Challenge</button>
        </div>
        <div className="card p-4">
          <h3 className="font-semibold">Leaderboard Highlights</h3>
          <p className="mt-2">See top scores across games.</p>
          <button className="btn mt-3" onClick={()=>setSection('leaderboard')}>View Leaderboards</button>
        </div>
      </div>

      <div className="mt-6 card p-4">
        <h3 className="font-semibold">Featured ‚Äî Trivia Tournament</h3>
        <p className="mt-2">Join a quick trivia run and try to beat the AI timer.</p>
        <button className="btn mt-3" onClick={()=>{ setActiveGame('Trivia'); setSection('play'); }}>Play Trivia</button>
      </div>
    </div>
  );
}

function GamesHub({ onOpen }){
  const games = [
    { key:'Memory', desc:'Flip matching cards' },
    { key:'TicTacToe', desc:'Classic X vs O with AI option' },
    { key:'2048', desc:'Slide & merge tiles' },
    { key:'Snake', desc:'Collect food, grow' },
    { key:'Minesweeper', desc:'Clear without mines' },
    { key:'Simon', desc:'Repeat the color sequence' },
    { key:'Trivia', desc:'Answer quick questions' },
    { key:'WhackAMole', desc:'Tap moles fast' },
    { key:'SlidingPuzzle', desc:'Arrange tiles' },
    { key:'Pong', desc:'Classic table tennis' },
  ];
  return (
    <div>
      <h2 className="text-2xl font-bold">All Games</h2>
      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
        {games.map(g => (
          <div key={g.key} className="card p-4">
            <h4 className="font-semibold">{g.key}</h4>
            <p className="text-sm mt-1">{g.desc}</p>
            <div className="mt-3 flex gap-2">
              <button className="btn" onClick={()=>onOpen(g.key)}>Play</button>
              <button className="btn outline" onClick={()=>alert('Tutorial: try to beat your high score!')}>Tutorial</button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// ----------------------
// Game Shell
// ----------------------
function GameShell({ gameKey, registerScore, grantAchievement, settings, notifications }){
  const commonProps = { registerScore, grantAchievement, settings, notifications };
  return (
    <div>
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-bold">{gameKey}</h2>
      </div>
      <div className="card p-4">
        {gameKey === 'Memory' && <MemoryGame {...commonProps} />}
        {gameKey === 'TicTacToe' && <TicTacToe {...commonProps} />}
        {gameKey === '2048' && <Game2048 {...commonProps} />}
        {gameKey === 'Snake' && <SnakeGame {...commonProps} />}
        {gameKey === 'Minesweeper' && <Minesweeper {...commonProps} />}
        {gameKey === 'Simon' && <SimonGame {...commonProps} />}
        {gameKey === 'Trivia' && <TriviaGame {...commonProps} />}
        {gameKey === 'WhackAMole' && <WhackAMole {...commonProps} />}
        {gameKey === 'SlidingPuzzle' && <SlidingPuzzle {...commonProps} />}
        {gameKey === 'Pong' && <PongGame {...commonProps} />}
      </div>
    </div>
  );
}

// ----------------------
// 1) Memory
// ----------------------
function MemoryGame({ registerScore, grantAchievement }){
  const size = 4; // 4x4
  const total = size*size;
  const createDeck = ()=>{
    const pairs = total/2;
    const items = [];
    for(let i=0;i<pairs;i++) items.push({ id:i, label: String.fromCharCode(65+i) });
    const full = [...items, ...items].map((c, idx)=>({ ...c, uid: uid() }));
    for(let i=full.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [full[i],full[j]]=[full[j],full[i]]; }
    return full.map(c=>({ ...c, flipped:false, matched:false }));
  };

  const [deck, setDeck] = useState(createDeck);
  const [firstIndex, setFirstIndex] = useState(null);
  const [moves, setMoves] = useState(0);
  const [matchedCount, setMatchedCount] = useState(0);

  const flip = (i)=>{
    setDeck(prev=>{
      const d = prev.map(x=>({ ...x }));
      if(d[i].flipped || d[i].matched) return prev;
      d[i].flipped = true;
      if(firstIndex===null){ setFirstIndex(i); return d; }
      else {
        setMoves(m=>m+1);
        const a = d[firstIndex]; const b = d[i];
        if(a.id === b.id){ d[firstIndex].matched = true; d[i].matched = true; setMatchedCount(c=>c+2); setFirstIndex(null); return d; }
        else {
          // keep flipped briefly then flip back
          setTimeout(()=> setDeck(prev2 => prev2.map((x, idx)=> idx===firstIndex||idx===i ? { ...x, flipped:false } : x)), 700);
          setFirstIndex(null);
          return d;
        }
      }
    });
  };

  useEffect(()=>{
    if(matchedCount === total && total>0){ const score = Math.max(1000 - moves*10, 10); registerScore('Memory', score); grantAchievement('memory_master', 'Completed Memory game'); }
  }, [matchedCount]);

  const reset = ()=>{ setDeck(createDeck()); setFirstIndex(null); setMoves(0); setMatchedCount(0); };

  return (
    <div>
      <div className="grid grid-cols-4 gap-2 max-w-md">
        {deck.map((c, i)=> (
          <button key={c.uid} className={`p-3 aspect-square rounded border flex items-center justify-center cursor-pointer ${c.flipped||c.matched ? 'bg-white' : 'bg-gray-300'}`} onClick={()=>flip(i)}>
            <div className="text-2xl font-bold">{(c.flipped||c.matched) ? c.label : ''}</div>
          </button>
        ))}
      </div>
      <div className="mt-3 flex items-center gap-3">
        <div>Moves: {moves}</div>
        <button className="btn" onClick={reset}>Reset</button>
      </div>
    </div>
  );
}

// ----------------------
// 2) TicTacToe with simple AI
// ----------------------
function TicTacToe({ registerScore, grantAchievement }){
  const [board, setBoard] = useState(Array(9).fill(null));
  const [xTurn, setXTurn] = useState(true);
  const [aiOn, setAiOn] = useState(true);
  const winner = calcWinner(board);

  useEffect(()=>{ if(winner){ registerScore('TicTacToe', 100); grantAchievement('ttt_winner', 'Won a TicTacToe game'); } }, [winner]);

  useEffect(()=>{
    if(!xTurn && aiOn && !winner){ // simple AI for O
      const idx = chooseBestMove(board, 'O');
      if(idx!==null) setTimeout(()=> play(idx), 350);
    }
  }, [xTurn, aiOn, winner]);

  const play = (i)=>{
    setBoard(prev=>{ if(prev[i] || winner) return prev; const b = prev.slice(); b[i] = xTurn ? 'X' : 'O'; setXTurn(!xTurn); return b; });
  };

  const reset = ()=>{ setBoard(Array(9).fill(null)); setXTurn(true); };

  return (
    <div>
      <div className="grid grid-cols-3 gap-2 max-w-xs">
        {board.map((v,i)=> (
          <button key={i} className="p-6 border text-2xl" onClick={()=>play(i)}>{v}</button>
        ))}
      </div>
      <div className="mt-3">{winner ? `Winner: ${winner}` : `Turn: ${xTurn ? 'X' : 'O'}`}</div>
      <div className="mt-2 flex gap-2">
        <button className="btn" onClick={reset}>Reset</button>
        <label className="ml-2">AI (O): <input type="checkbox" checked={aiOn} onChange={(e)=>setAiOn(e.target.checked)} /></label>
      </div>
    </div>
  );
}

function calcWinner(b){
  const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const [a,c,d] of lines){ if(b[a] && b[a] === b[c] && b[a] === b[d]) return b[a]; }
  return null;
}

function chooseBestMove(board, player){
  // Very simple heuristic: take winning move, block opponent winning move, else random
  const opponent = player === 'X' ? 'O' : 'X';
  for(let i=0;i<9;i++){
    if(!board[i]){ const b = board.slice(); b[i]=player; if(calcWinner(b)===player) return i; }
  }
  for(let i=0;i<9;i++){
    if(!board[i]){ const b = board.slice(); b[i]=opponent; if(calcWinner(b)===opponent) return i; }
  }
  const empties = board.map((v,i)=> v? null : i).filter(Boolean);
  if(empties.length===0) return null;
  return empties[Math.floor(Math.random()*empties.length)];
}

// ----------------------
// 3) 2048 with robust move detection
// ----------------------
function Game2048({ registerScore, grantAchievement }){
  const size = 4;
  const emptyGrid = ()=> Array(size).fill(0).map(()=>Array(size).fill(0));
  const [grid, setGrid] = useState(()=>{ const g = emptyGrid(); addTile(g); addTile(g); return g; });

  function addTile(g){
    const empties = [];
    for(let r=0;r<size;r++) for(let c=0;c<size;c++) if(g[r][c]===0) empties.push([r,c]);
    if(empties.length===0) return false;
    const [r,c] = empties[Math.floor(Math.random()*empties.length)]; g[r][c] = Math.random()<0.9?2:4; return true;
  }
  function clone(g){ return g.map(row=>row.slice()); }
  function rotate(g){ const n = clone(g); for(let r=0;r<size;r++) for(let c=0;c<size;c++) n[c][size-1-r]=g[r][c]; return n; }
  function moveLeft(g){ let score=0; let moved=false; for(let r=0;r<size;r++){ let row = g[r].filter(x=>x!==0); for(let i=0;i<row.length-1;i++){ if(row[i]===row[i+1]){ row[i]*=2; score+=row[i]; row.splice(i+1,1); } } while(row.length<size) row.push(0); if(row.some((v,i)=>v!==g[r][i])) moved=true; g[r]=row; } return {grid:g,score,moved}; }

  const doMove = (dir)=>{
    let g = clone(grid); let rotated=0;
    if(dir==='up'){ g = rotate(g); rotated=1; }
    if(dir==='right'){ g = rotate(rotate(g)); rotated=2; }
    if(dir==='down'){ g = rotate(rotate(rotate(g))); rotated=3; }
    const {grid:after, score, moved} = moveLeft(g);
    let g2 = after;
    for(let i=0;i<(4-rotated)%4;i++) g2 = rotate(g2);
    if(moved){ addTile(g2); setGrid(g2); if(score>0){ registerScore('2048', score); grantAchievement('2048_merge', 'Merged tiles in 2048'); } }
  };

  const isOver = ()=>{
    for(let r=0;r<size;r++) for(let c=0;c<size;c++) if(grid[r][c]===0) return false;
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){ if(r+1<size && grid[r][c]===grid[r+1][c]) return false; if(c+1<size && grid[r][c]===grid[r][c+1]) return false; }
    return true;
  };

  useEffect(()=>{
    const onKey = (e)=>{
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){ e.preventDefault(); if(e.key==='ArrowLeft') doMove('left'); if(e.key==='ArrowRight') doMove('right'); if(e.key==='ArrowUp') doMove('up'); if(e.key==='ArrowDown') doMove('down'); }
    };
    window.addEventListener('keydown', onKey);
    return ()=> window.removeEventListener('keydown', onKey);
  }, [grid]);

  const reset = ()=> setGrid(()=>{ const g = emptyGrid(); addTile(g); addTile(g); return g; });

  return (
    <div>
      <div className="grid gap-2" style={{gridTemplateColumns:`repeat(${size}, 1fr)`, maxWidth: 340}}>
        {grid.flat().map((v,i)=> <div key={i} className="p-3 aspect-square border flex items-center justify-center text-lg font-bold">{v||''}</div>)}
      </div>
      <div className="mt-3 flex gap-2">
        <button className="btn" onClick={()=>doMove('left')}>Left</button>
        <button className="btn" onClick={()=>doMove('up')}>Up</button>
        <button className="btn" onClick={()=>doMove('down')}>Down</button>
        <button className="btn" onClick={()=>doMove('right')}>Right</button>
        <button className="btn outline" onClick={reset}>Reset</button>
      </div>
      {isOver() && <div className="mt-2 font-semibold">Game Over</div>}
    </div>
  );
}

// ----------------------
// 4) Snake (improved)
// ----------------------
function SnakeGame({ registerScore, grantAchievement }){
  const canvasRef = useRef();
  const [running, setRunning] = useState(true);
  const [score, setScore] = useState(0);
  const gameRef = useRef({});

  useEffect(()=>{
    const canvas = canvasRef.current; const ctx = canvas.getContext('2d');
    const scale = 20; const cols = 20; const rows = 20; const W = cols*scale; const H = rows*scale;
    canvas.width = W; canvas.height = H;
    let snake = [{x:10,y:10}]; let dir = {x:1,y:0}; let food = {x:5,y:5}; let id=null; let localScore=0; let speed = 120;

    const placeFood = ()=>{ food = { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) }; if(snake.some(s=>s.x===food.x && s.y===food.y)) placeFood(); };
    const draw = ()=>{
      ctx.fillStyle='black'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='lime'; snake.forEach(s=>ctx.fillRect(s.x*scale+1,s.y*scale+1,scale-2,scale-2));
      ctx.fillStyle='red'; ctx.fillRect(food.x*scale+1,food.y*scale+1,scale-2,scale-2);
      ctx.fillStyle='white'; ctx.fillText('Score: '+localScore, 8, 12);
    };

    const step = ()=>{
      if(!running) return;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      if(head.x<0||head.y<0||head.x>=cols||head.y>=rows || snake.some(s=>s.x===head.x && s.y===head.y)){ setRunning(false); registerScore('Snake', localScore); grantAchievement('snake_game', 'Played Snake'); return; }
      snake.unshift(head);
      if(head.x===food.x && head.y===food.y){ localScore+=10; setScore(localScore); placeFood(); }
      else snake.pop();
      draw();
      id = setTimeout(step, speed);
    };

    const onKey = (e)=>{
      if(e.key==='ArrowUp' && dir.y!==1) dir={x:0,y:-1};
      if(e.key==='ArrowDown' && dir.y!==-1) dir={x:0,y:1};
      if(e.key==='ArrowLeft' && dir.x!==1) dir={x:-1,y:0};
      if(e.key==='ArrowRight' && dir.x!==-1) dir={x:1,y:0};
      if(e.key==='p'){ setRunning(r=>!r); }
    };

    placeFood(); draw(); step();
    window.addEventListener('keydown', onKey);
    gameRef.current = { stop: ()=>{ clearTimeout(id); window.removeEventListener('keydown', onKey); } };
    return ()=>{ gameRef.current.stop(); };
  }, [running]);

  return (
    <div>
      <canvas ref={canvasRef} className="border" />
      <div className="mt-2 flex gap-2"><button className="btn" onClick={()=>{ setRunning(true); location.reload(); /* fallback quick restart */ }}>Restart (quick)</button></div>
    </div>
  );
}

// ----------------------
// 5) Minesweeper (fixed grid init)
// ----------------------
function Minesweeper({ registerScore, grantAchievement }){
  const rows = 8, cols = 8, mines = 10;
  const createMap = ()=>{
    const map = Array(rows).fill(null).map(()=>Array(cols).fill(null));
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) map[r][c] = { mine:false, revealed:false, flag:false, count:0 };
    const cells = [];
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) cells.push([r,c]);
    cells.sort(()=>Math.random()-0.5);
    const mineCoords = cells.slice(0,mines);
    mineCoords.forEach(([r,c])=> map[r][c].mine = true);
    const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
      if(map[r][c].mine) continue;
      let cnt=0; dirs.forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(nr>=0 && nr<rows && nc>=0 && nc<cols && map[nr][nc].mine) cnt++; });
      map[r][c].count = cnt;
    }
    return map;
  };

  const [grid, setGrid] = useState(createMap);
  const reveal = (r,c)=>{
    setGrid(prev=>{
      const g = prev.map(row=>row.map(cell=>({ ...cell })));
      if(g[r][c].revealed || g[r][c].flag) return prev;
      g[r][c].revealed = true;
      if(g[r][c].mine){ // reveal all
        for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) if(g[i][j].mine) g[i][j].revealed = true;
        registerScore('Minesweeper', 0); grantAchievement('mines_fail','Hit a mine');
      } else if(g[r][c].count===0){ const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]; dirs.forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(nr>=0&&nr<rows&&nc>=0&&nc<cols && !g[nr][nc].revealed) { g[nr][nc].revealed = true; if(g[nr][nc].count===0) reveal(nr,nc); } }); }
      return g;
    });
  };
  const toggleFlag = (e,r,c)=>{ e.preventDefault(); setGrid(prev => { const g = prev.map(row=>row.map(cell=>({ ...cell }))); g[r][c].flag = !g[r][c].flag; return g; }); };
  const reset = ()=> setGrid(createMap());
  return (
    <div>
      <div className="grid gap-1" style={{gridTemplateColumns:`repeat(${cols}, 1fr)`, maxWidth:360}}>
        {grid.flat().map((cell,i)=>{
          const r = Math.floor(i/cols), c = i%cols;
          return (
            <button key={i} onClick={()=>reveal(r,c)} onContextMenu={(e)=>toggleFlag(e,r,c)} className={`p-2 aspect-square border flex items-center justify-center cursor-pointer ${cell.revealed ? 'bg-white' : 'bg-gray-300'}`}>
              {cell.revealed ? (cell.mine ? 'üí£' : (cell.count||'')) : (cell.flag ? 'üö©' : '')}
            </button>
          );
        })}
      </div>
      <div className="mt-3 flex gap-2"><button className="btn" onClick={reset}>Reset</button></div>
    </div>
  );
}

// ----------------------
// 6) Simon Says
// ----------------------
function SimonGame({ registerScore, grantAchievement }){
  const colors = ['red','green','blue','yellow'];
  const [seq,setSeq] = useState([]);
  const [index,setIndex] = useState(0);
  const [playing,setPlaying]=useState(false);
  const [message,setMessage]=useState('Start to play');

  const addStep = ()=> setSeq(s=>[...s, colors[Math.floor(Math.random()*colors.length)]]);
  const playSeq = async ()=>{
    setPlaying(true); for(const c of seq){ setMessage('Watch'); await new Promise(r=>setTimeout(r,400)); setMessage(c); await new Promise(r=>setTimeout(r,400)); setMessage(''); }
    setMessage('Your turn'); setPlaying(false);
  };
  useEffect(()=>{ if(seq.length>0) playSeq(); }, [seq]);
  const start = ()=>{ setSeq([]); setIndex(0); addStep(); };
  const choose = (c)=>{
    if(playing) return;
    if(c === seq[index]){ setIndex(i=>i+1); if(index+1 === seq.length){ registerScore('Simon', seq.length*10); addStep(); setIndex(0); setMessage('Nice!'); } }
    else { setMessage('Wrong! Game Over'); registerScore('Simon', seq.length*5); setSeq([]); setIndex(0); }
  };
  return (
    <div>
      <div className="grid grid-cols-2 gap-2 max-w-xs">
        {colors.map(c=> <button key={c} className={`p-6 border rounded ${c==='red'? 'bg-red-400': c==='green'? 'bg-green-400': c==='blue'? 'bg-blue-400': 'bg-yellow-300'}`} onClick={()=>choose(c)}>{c}</button>)}
      </div>
      <div className="mt-3">Seq length: {seq.length} ‚Äî {message}</div>
      <div className="mt-2"><button className="btn" onClick={start}>Start</button></div>
    </div>
  );
}

// ----------------------
// 7) Trivia
// ----------------------
function TriviaGame({ registerScore, grantAchievement, notifications }){
  const questions = [
    {q:'Capital of France?', a:['Paris','Rome','Berlin','Madrid'], correct:0},
    {q:'2+2*2=?', a:['4','6','8','2'], correct:1},
    {q:'Which is prime?', a:['9','15','17','21'], correct:2},
  ];
  const [i, setI] = useState(0); const [score,setScore] = useState(0);
  const answer = (idx)=>{ if(idx===questions[i].correct) setScore(s=>s+10); if(i+1<questions.length) setI(i+1); else { const final = score+ (idx===questions[i].correct?10:0); registerScore('Trivia', final); grantAchievement('trivia_finisher','Finished a trivia run'); notifications.push('Trivia finished: '+final); } };
  return (
    <div>
      <h3 className="font-semibold">{questions[i].q}</h3>
      <div className="mt-2 grid gap-2">
        {questions[i].a.map((ans, idx)=> <button key={idx} className="btn" onClick={()=>answer(idx)}>{ans}</button>)}
      </div>
      <div className="mt-3">Score: {score}</div>
    </div>
  );
}

// ----------------------
// 8) Whack-a-mole
// ----------------------
function WhackAMole({ registerScore, grantAchievement }){
  const [holes, setHoles] = useState(Array(6).fill(false));
  const [score, setScore] = useState(0);
  useEffect(()=>{ let running=true; const tick=()=>{ if(!running) return; const idx=Math.floor(Math.random()*holes.length); setHoles(h=>h.map((_,i)=>i===idx)); setTimeout(tick, 700); }; tick(); return ()=>{ running=false }; },[]);
  const hit = (i)=>{ if(holes[i]){ setScore(s=>s+10); setHoles(h=>h.map(()=>false)); registerScore('WhackAMole', score+10); grantAchievement('whack_pro','Hit a mole'); } };
  return (
    <div>
      <div className="grid grid-cols-3 gap-2 max-w-sm">
        {holes.map((h,i)=> <button key={i} className="p-4 border aspect-square flex items-center justify-center cursor-pointer" onClick={()=>hit(i)}>{h? 'üêπ':' '}</button>)}
      </div>
      <div className="mt-3">Score: {score}</div>
    </div>
  );
}

// ----------------------
// 9) Sliding Puzzle with solvable shuffle
// ----------------------
function SlidingPuzzle({ registerScore, grantAchievement }){
  const size = 3;
  const solved = (arr)=> arr.slice(0,arr.length-1).every((v,i)=> v===i+1);
  const create = ()=>{
    // create solvable permutation for NxN sliding puzzle
    const arr = [...Array(size*size).keys()].map(i=> i===0? 0: i).slice(1).concat([0]); // 1..n-1,0
    // shuffle by making legal moves from solved state
    let grid = arr.slice();
    const movesCount = 1000;
    const idxToRC = (idx)=> [Math.floor(idx/size), idx%size];
    const rcToIdx = (r,c)=> r*size + c;
    for(let k=0;k<movesCount;k++){
      const emptyIdx = grid.indexOf(0); const [er,ec] = idxToRC(emptyIdx); const neighbors=[];
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{ const nr=er+dr,nc=ec+dc; if(nr>=0&&nr<size&&nc>=0&&nc<size) neighbors.push(rcToIdx(nr,nc)); });
      const pick = neighbors[Math.floor(Math.random()*neighbors.length)]; [grid[emptyIdx], grid[pick]] = [grid[pick], grid[emptyIdx]];
    }
    return grid;
  };

  const [tiles, setTiles] = useState(create);
  const move = (i)=>{
    const idxEmpty = tiles.indexOf(0); const r = Math.floor(idxEmpty/size), c = idxEmpty%size; const ir = Math.floor(i/size), ic = i%size;
    if(Math.abs(r-ir)+Math.abs(c-ic)===1){ const t = tiles.slice(); t[idxEmpty]=t[i]; t[i]=0; setTiles(t); if(solved(t)){ registerScore('SlidingPuzzle', 200); grantAchievement('sliding_master','Solved sliding puzzle'); } }
  };
  const shuffle = ()=> setTiles(create());
  return (
    <div>
      <div className="grid gap-1" style={{gridTemplateColumns:`repeat(${size}, 1fr)`, maxWidth:240}}>
        {tiles.map((t,i)=> <button key={i} className={`p-4 aspect-square border flex items-center justify-center cursor-pointer ${t===0? 'bg-gray-200':''}`} onClick={()=>move(i)}>{t===0 ? '' : t}</button>)}
      </div>
      <div className="mt-3"><button className="btn" onClick={shuffle}>Shuffle</button></div>
    </div>
  );
}

// ----------------------
// 10) Pong (simple improved)
// ----------------------
function PongGame({ registerScore, grantAchievement }){
  const canvasRef = useRef();
  useEffect(()=>{
    const canvas = canvasRef.current; const ctx = canvas.getContext('2d');
    const W=600,H=300; canvas.width=W; canvas.height=H; let paddleY=(H-60)/2; let ball={x:300,y:150,vx:3,vy:2}; let score=0; let id;
    const loop=()=>{
      ctx.fillStyle='black'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='white'; ctx.fillRect(10,paddleY,10,60);
      ctx.beginPath(); ctx.arc(ball.x,ball.y,8,0,Math.PI*2); ctx.fill();
      ball.x+=ball.vx; ball.y+=ball.vy;
      if(ball.y<0||ball.y>H) ball.vy=-ball.vy;
      if(ball.x<20 && ball.x>10 && ball.y>paddleY && ball.y<paddleY+60){ ball.vx=-ball.vx; score+=1; }
      if(ball.x<0) { registerScore('Pong', score); grantAchievement('pong_player','Played Pong'); alert('Missed! Score: '+score); cancelAnimationFrame(id); return; }
      if(ball.x>W) ball.vx=-ball.vx;
      id = requestAnimationFrame(loop);
    };
    const onMove = (e)=>{ const rect = canvas.getBoundingClientRect(); const y = (e.clientY - rect.top) - 30; paddleY = clamp(y, 0, H-60); };
    canvas.addEventListener('mousemove', onMove);
    loop();
    return ()=>{ cancelAnimationFrame(id); canvas.removeEventListener('mousemove', onMove); };
  }, []);
  return (
    <div>
      <canvas ref={canvasRef} width={600} height={300} className="border" />
      <div className="mt-2">Move your mouse over the canvas to control the paddle.</div>
    </div>
  );
}

// ----------------------
// Profile / Leaderboards / Settings / About
// ----------------------
function Leaderboards({ scores }){
  return (
    <div>
      <h2 className="text-xl font-bold">Leaderboards</h2>
      <div className="grid sm:grid-cols-2 gap-4 mt-4">
        {Object.keys(scores).length===0 && <div>No scores yet ‚Äî play to populate leaderboards.</div>}
        {Object.entries(scores).map(([k,arr])=> (
          <div key={k} className="card p-3">
            <h4 className="font-semibold">{k}</h4>
            <ol className="mt-2 list-decimal ml-5">
              {arr.map((s)=> <li key={s.id}>{s.name}: {s.score} <span className="opacity-60 text-xs">({new Date(s.date).toLocaleString()})</span></li>)}
            </ol>
          </div>
        ))}
      </div>
    </div>
  );
}

function Profile({ user, setUser, achievements, scores }){
  const myScores = Object.entries(scores).flatMap(([k,arr])=> arr.filter(s=>s.name===user.name).map(s=>({game:k,score:s.score,date:s.date,id:s.id}))).sort((a,b)=>b.score-a.score);
  return (
    <div>
      <h2 className="text-xl font-bold">Profile ‚Äî {user.name}</h2>
      <div className="mt-3 grid sm:grid-cols-2 gap-4">
        <div className="card p-3">
          <h4 className="font-semibold">Achievements</h4>
          <ul className="mt-2">
            {Object.values(achievements).length===0 && <li className="opacity-60">No achievements yet.</li>}
            {Object.values(achievements).map(a=> <li key={a.id}>{a.text} <span className="opacity-60">({new Date(a.date).toLocaleDateString()})</span></li>)}
          </ul>
        </div>
        <div className="card p-3">
          <h4 className="font-semibold">Your top scores</h4>
          <ul className="mt-2">
            {myScores.length===0 && <li className="opacity-60">No personal scores yet.</li>}
            {myScores.map(s=> <li key={s.id}>{s.game}: {s.score} <span className="opacity-60">({new Date(s.date).toLocaleString()})</span></li>)}
          </ul>
        </div>
      </div>
    </div>
  );
}

function Settings({ settings, setSettings, user, setUser }){
  return (
    <div>
      <h2 className="text-xl font-bold">Settings</h2>
      <div className="mt-3 card p-3">
        <label className="block">Difficulty
          <select className="ml-2" value={settings.difficulty} onChange={(e)=>setSettings({...settings, difficulty:e.target.value})}>
            <option>easy</option><option>normal</option><option>hard</option>
          </select>
        </label>
        <label className="block mt-2">Theme
          <select className="ml-2" value={user.theme} onChange={(e)=>setUser({...user, theme:e.target.value})}>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </label>
        <label className="block mt-2">Sound
          <input type="checkbox" className="ml-2" checked={user.sound} onChange={(e)=>setUser({...user, sound:e.target.checked})} />
        </label>
      </div>
    </div>
  );
}

function About(){
  return (
    <div>
      <h2 className="text-xl font-bold">About this project</h2>
      <p className="mt-2">This single-file React app bundles many tiny games with local leaderboards, achievements and small features. It's intended as a playground ‚Äî extendable and modular.</p>
      <ul className="mt-2 list-disc ml-6">
        <li>10+ games (small implementations)</li>
        <li>Local storage for user, scores, achievements</li>
        <li>Quick play, tutorials, settings, notifications</li>
      </ul>
    </div>
  );
}

/*
Notes:
- I avoided using location.reload() except as a harmless fallback text in one quick-restart button ‚Äî most game components now provide proper reset logic.
- Canvas-based games use addEventListener and always remove listeners in cleanup.
- Sliding puzzle shuffle now always returns a solvable state by performing legal moves from solved configuration.

If you still see a specific error, —Å–∫–∞–∂–∏—Ç–µ —Ç–æ—á–Ω—É—é –æ—à–∏–±–∫—É –∏–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏ ‚Äî —è –±—ã—Å—Ç—Ä–æ –ø–æ–ø—Ä–∞–≤–ª—é.
–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ, –º–æ–≥—É:
- —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª –≤ zip/—Å–¥–µ–ª–∞—Ç—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π scaffold;
- –≤—ã–Ω–µ—Å—Ç–∏ –∫–æ–¥ –ø–æ –º–æ–¥—É–ª—è–º (–∫–∞–∂–¥–∞—è –∏–≥—Ä–∞ –≤ —Å–≤–æ–µ–π –ø–∞–ø–∫–µ);
- –¥–æ–±–∞–≤–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –æ–±–ª–∞–∫–æ/–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é;
- —É–ª—É—á—à–∏—Ç—å UI/UX –∏ —Ç–µ–º—É.
*/
